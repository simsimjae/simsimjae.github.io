{"componentChunkName":"component---src-components-templates-page-template-js","path":"/posts/TIL/12","result":{"data":{"markdownRemark":{"html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 691px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/a84d56f68b18df13eb0b0eb22d7c112a/eca22/2020_01_17_13_47_55.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 65.41244573082489%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABo0lEQVQoz4VSWXbkIAzs+3/kFHOEOUv+MrGTGO+YHYShe0p2p5N8xQ/zhERRpeVyu91KKd6HiC+la62+5FJrOo4hYCOqJZWdEvkQ0uGstQJ4wR9CaJr27f2jE2Kn3HjlMwnRd6KHexknSbEPdh7nf6/t6SQiBl+vIKvYcahssp33fS/lm72zddw5v3KELtDMUog+VxLzoqx9G6ZWDP00G+dSJuAnub12/bhKREOKDAYD5fx4EngQIVFt7bmMs0QZ15R1Uhu85QKn/gOciPe851Vp6/wot2GVErYPuIBr0hiQb4bxd2akhNxWbZ/+/DUuIAvjUPuwbGpRajMAe4ALM9t+kQCDGQLvzMDHRM8v71AHG93xMW7aSK1PHmbeWfaqNY72u2xEAAMDaggb2oz33bx00zxL+WCepGqHcZRy+yoYI78KBhtZYD6s58QwOkfBCGCo1c75CNoYKd1bFRHjBtdSuXhi4la1w9SIXsxo1Z0ZJWzEuCoF/fGUfY4BXh2WFWXIOV8re5BV/Fw8MaVgh3OWCtF8iL08JgZluP32HTTxcfwPJFTuSslxYVUAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"2020 01 17 13 47 55\"\n        title=\"2020 01 17 13 47 55\"\n        src=\"/static/a84d56f68b18df13eb0b0eb22d7c112a/eca22/2020_01_17_13_47_55.png\"\n        srcset=\"/static/a84d56f68b18df13eb0b0eb22d7c112a/8c2ab/2020_01_17_13_47_55.png 300w,\n/static/a84d56f68b18df13eb0b0eb22d7c112a/3f01f/2020_01_17_13_47_55.png 600w,\n/static/a84d56f68b18df13eb0b0eb22d7c112a/eca22/2020_01_17_13_47_55.png 691w\"\n        sizes=\"(max-width: 691px) 100vw, 691px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>\n프로젝트 구조를 구성하는 방식 3가지가 위에 나와있다. <code class=\"language-text\">모놀리스</code>, <code class=\"language-text\">멀티레포</code>, <code class=\"language-text\">모노레포</code>이다. </p>\n<p><code class=\"language-text\">모놀리스</code> 구조는 하나의 레포지토리안에 하나의 패키지안에 여러개의 서비스가 폴더로 구분된다.<br>\n<code class=\"language-text\">멀티레포</code> 구조는 하나의 레포지토리안에 하나의 패키지안에 하나의 서비스가 들어간다.<br>\n<code class=\"language-text\">모노레포</code> 구조는 하나의 레포지토리안에 큰 공통 패키지하나안에 여러개의 서브 패키지들(서비스)이 들어있다.</p>\n<p><code class=\"language-text\">모놀리스</code> 구조는 비슷한 여러개의 소규모 프로젝트들을 한번에 관리할때 좋은 구조인것같다.</p>\n<p><code class=\"language-text\">멀티레포</code> 구조는 서비스의 규모가 커서 각 서비스를 별도 관리해서 서비스간 의존성을 줄이고 싶을때 쓰면 좋은 구조인것같다. 마이크로 서비스 아키텍쳐라고도 불리는것같다.  </p>\n<p><code class=\"language-text\">모노레포</code> 구조는 마찬가지로 서비스의 규모가 커졌을때, 각 서비스간 분리도 되면서 공통 구조를 가져가고 싶을때 사용하면 좋을것같다.</p>\n<h1>모노레포</h1>\n<p>모노레포라는것은 1개의 <code class=\"language-text\">git repository</code>가 존재한다는 뜻이다.<br>\n그 레포지토리안에는 하나의 큰 공통 패키지 안에 여러개의 서브 패키지가 들어있다.</p>\n<h1>모노 레포의 장점</h1>\n<h2>1. 패키지별로 배포하기 쉬워진다.</h2>\n<p>모노레포의 서브 패키지 <code class=\"language-text\">A</code>와 <code class=\"language-text\">B</code>가 있다고 해보자. A패키지는 B패키지의 모듈을 가져와서 사용한다.\n이떄 A패키지에 새로운 기능을 추가하고나서 커맨드 한줄 입력하게되면 B패키지에 문제를 일으키지않고 A패키지가 배포된다.</p>\n<h2>2. 의존성 관리가 간편해진다.</h2>\n<p>하나의 공통 패키지안에 여러 서브 패키지들이 있기 떄문에 각 서브 패키지들이 공통으로 사용하는 의존성들은 공통 패키지에 넣으면 된다.\n각 서브 패키지별로 다르게 사용해야하는 의존성들은 각 서브 패키지에 명시하면 된다.</p>\n<p>멀티레포였으면 이렇게 여러개의 레포지토리에서 공통으로 사용하는 의존성 관리를 하기가 어려워진다.</p>\n<h2>3. 이슈관리가 간편해진다.</h2>\n<p>멀티레포였으면 각 레포지토리 별로 이슈가 분산된다. A와 B레포지토리 둘다에서 발생한 문제인데 어떤경우에는 A레포에만 이슈를 올리고 B는 빠트릴수가있다. 사람이 모든 레포지토리를 매번 관리하기가 힘들기 때문이다.\n하지만 모노레포는 하나의 레포지토리에 모두 코드가 몰려있으므로 그 레포지토리에서 이슈를 생성하고 히스토리가 쌓이게 할 수 있다.</p>\n<h2>4. 각 서브 패키지가 독립적이면서, 서로를 공유할수있다.</h2>\n<p><strong>개인적으로 모노레포의 가장 큰 장점이라고 생각하는 부분이다.</strong> 각 서브 패키지들은 서로를 <code class=\"language-text\">심볼릭 링크</code>로 연결한다.\n이 <code class=\"language-text\">심볼릭 링크</code>로 연결되있는게 무슨 뜻이냐면, A서브 패키지의 수정사항이 B서브 패키지에 바로바로 반영된다는것이다.\n각 패키지를 수정한다음에 배포하지 않고서도 로컬 컴퓨터에서 의존하고 있는 다른 패키지에 바로바로 반영되기 때문에 개발 생산성이 매우 올라가게 된다.</p>\n<p><a href=\"https://simsimjae.github.io/posts/TIL/10\">심볼릭 링크에 대해서 알아보기</a></p>\n<p>이걸 직접 구현할수도 있지만 <code class=\"language-text\">Yarn Workspace</code>나 <code class=\"language-text\">Lerna</code>를 사용하면 좀 더 간편하게 사용 할 수 있다.</p>\n<h1>모노레포 vs 멀티레포</h1>\n<p>멀티레포는 말그대로 레포지토리가 여러개 있다는 뜻이다. 레포지토리가 여러개면 좋은점이 있다. <strong>바로 권한 관리를 레포지토리 별로 따로 할 수 있다는것이다.</strong>\n예를들어, 스타트업에서는 개발자가 빈번히 입사/퇴사한다. 이럴때 모노레포로 프로젝트를 만들어두면 개발자 한명이 회사의 전체 코드에 접근할수있게된다.\n근데 또 개발자들끼리 여러 프로젝트의 코드에 접근할수있다는게 어떻게 보면 장점이기도하다.</p>\n<p>왜냐면 개발자 한명이 휴가를 가거나 부재했을때, 평소에 서로의 프로젝트를 크로스로 봐주고 있었으면 그 공백을 다른 개발자가 메꾸기 쉽기 때문이다.\n<strong>이런점은 모노레포의 장점이자 단점이라고 할 수 있다.</strong></p>\n<p>반면에 멀티레포는 각 직원에게 필요한 레포지토리의 권한만 주어서 관리하게 할 수 있다는 장점이 있다.</p>\n<p>모노레포가 멀티레포보다 좋은점은, <strong>모노레포는 공통화가 쉽다는것이다.</strong> 서비스가 한두개일땐 상관없는데 이게 50개 100개가 되는경우에 멀티레포로 이 모든 서비스를 관리하게되면\n굉장히 힘들어진다.</p>\n<p>따라서, 모노레포로 프로젝트를 구성해두면 하나의 큰 패키지안에 여러개의 서브 패키지들로 서비스들을 관리할수있기때문에 멀티레포보다 훨씬 관리하기가 편하다.</p>\n<p>이런 점들을 잘 고려해서 프로젝트 구조를 구성하면 될것같다.</p>\n<blockquote>\n<p>추가로 멀티레포가 모노레포보다 좋은점을 알고계신다면 댓글로 알려주세요.</p>\n</blockquote>\n<h1>모노레포 구성</h1>\n<h2>Lerna</h2>\n<p>모노레포 구성을 쉽게 할 수 있도록 도와주는 라이브러리이다.\n모노레포 안의 각 패키지를 묶어서 버전관리할지, 각 패키지마다 버전관리할지 등등을 정할수있다.</p>\n<h2>Yarn Workspace</h2>\n<p>npm과 비슷한 패키지 매니저인 Yarn에서 Workspace기능을 제공한다.\n이것을 사용하게되면, 모노레포의 각 패키지안에 있는 <code class=\"language-text\">node_modules</code>가 프로젝트 루트의 <code class=\"language-text\">node_modules</code>를 참조하게 된다.</p>\n<p>Yarn에서 WorkSpace란 패키지와 동의어로 사용된다. 각 서브패키지들이 독립적이므로 어떤 프로젝트에는 타입스크립트 빌드 설정파일인 tsconfig.json을 넣을수도 있고 다른 서브 패키지에서는 그냥 js로 구성할수도있다.</p>\n<p>Yarn Workspace에서는 각 서브 패키지들의 의존성이 모두 루트에서 관리된다.  관리 자체는 루트에서 되지만 각 서브패키지별로 의존성 재설치는 할 수 있다.\n하지만 Lerna는 각 패키지별로도 관리하고 루트에서도 관리한다. 이런점이 두 라이브러리의 차이점이라고 할 수 있다.</p>\n<h1>Lerna로 모노레포 구성해보기</h1>\n<p><code class=\"language-text\">Lerna</code>를 사용해서 모노 레포를 구성해보면 다음과 같은 프로젝트 구조가 생긴다.</p>\n<div class=\"gatsby-highlight\" data-language=\"markdown\"><pre class=\"language-markdown\"><code class=\"language-markdown\">mylerna<span class=\"token italic\"><span class=\"token punctuation\">_</span><span class=\"token content\">repo/\n  - node</span><span class=\"token punctuation\">_</span></span>modules\n  <span class=\"token list punctuation\">-</span> packages\n\n<span class=\"token code keyword\">    - sub_package1\n      package.json</span>\n\n<span class=\"token code keyword\">    - sub_package2\n      package.json</span>\n\n<span class=\"token code keyword\">    - sub_package3\n      package.json</span>\n\n  lerna.json\n  package.json // 루트 패키지</code></pre></div>\n<p><code class=\"language-text\">mylerna_repo</code>라고 하는 하나의 큰 레포지토리안에 루트 패키지 하나가 존재한다. 그 루트 패키지 안에는 <code class=\"language-text\">packages</code>폴더로 구분된 여러개의 서브 패키지들이 들어있다.\n각 서브 패키지에 들어있는 <code class=\"language-text\">package.json</code>으로 독립적인 의존성 관리가 가능해진다. 공통으로 관리되는 의존성은 루트의 <code class=\"language-text\">package.json</code>으로 관리된다.</p>\n<p>온라인 IDE로 유명한 <a href=\"https://github.com/despeauxz/codesandbox\">코드 샌드박스</a>는 <code class=\"language-text\">Yarn Workspace</code>와 <code class=\"language-text\">Lerna</code>를 혼합해서 사용하고 있다.</p>\n<p><code class=\"language-text\">Lerna</code>는 다음과 같은 두가지 방법으로 사용할 수 있다.</p>\n<ol>\n<li>NPM 저장소에 push없이 사용하기</li>\n<li>NPM 저장소에 push하면서 사용하기</li>\n</ol>\n<p>첫번째 방식을 사용하게 되면 각 서브 패키지들을 <code class=\"language-text\">심볼릭 링크</code>로 연결해서 사용한다. 이걸 <code class=\"language-text\">Lerna</code>가 자동으로 처리해주기 때문에 내가 신경쓰지 않아도 된다.</p>\n<p>두번쨰 방식을 사용하게 되면 <strong>import { something } from @name/packagename;</strong>와 같이 NPM 저장소에 올라가있는 패키지를 받아오기 떄문에 패키지를 매번 수정하고 푸쉬하고 다시 받아와서 테스트를 해봐야 해서 번거롭다.</p>\n<h2>lerna bootstrap 명령어 살펴보기</h2>\n<h3>이 명령어는 왜 사용해야 하는가?</h3>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">mylerna_repo<span class=\"token operator\">/</span>\n\tnode_modules<span class=\"token operator\">/</span>\n\tpackages<span class=\"token operator\">/</span>\n\t\t<span class=\"token constant\">A</span>\n\t\t\tnode_modules<span class=\"token operator\">/</span>\n\t\t\t\t<span class=\"token constant\">B</span>\n\t\t\t<span class=\"token keyword\">package</span><span class=\"token punctuation\">.</span>json\n\t\t\n\t\t<span class=\"token constant\">B</span>\n\t\t\t<span class=\"token keyword\">package</span><span class=\"token punctuation\">.</span>json</code></pre></div>\n<p>이런 프로젝트 구조가 있다고 해보자. A서브 패키지에서 B서브 패키지를 사용하고 있다. 이떄 그냥 A패키지에서 node_modules안에 있는 B패키지를 사용하게되면 B패키지의 내용이 수정됬을때 그 수정사항이 반영되지 않은채로 실행된다.\n그래서 의존관계에 있는 A와 B패키지를 로컬 컴퓨터에서 서로 <code class=\"language-text\">심볼릭 링크</code>로 연결해야 한다. </p>\n<p>만약 <code class=\"language-text\">mylerna_repo</code>에 100개의 서브 패키지가 있다고 해보자. 이거 일일이 <code class=\"language-text\">심볼릭 링크</code>로 연결할 자신이 있는가? 어마어마하게 귀찮은 작업이 될것이다. 실수할수도 있다.</p>\n<p>그렇기 떄문에 <code class=\"language-text\">lerna bootstrap</code>명령어를 사용해서 의존관계에 있는 서브 패키지들을 서로 <code class=\"language-text\">심볼릭 링크</code>로 연결을 먼저 해주고 웹팩으로 빌드해야한다.</p>\n<h1>출처</h1>\n<p><a href=\"https://medium.com/@deptno/monorepo-yarn-workspace-e81e3e078100\">https://medium.com/@deptno/monorepo-yarn-workspace-e81e3e078100</a><br>\n<a href=\"https://medium.com/@patrickleet/mono-repo-or-multi-repo-why-choose-one-when-you-can-have-both-e9c77bd0c668\">https://medium.com/@patrickleet/mono-repo-or-multi-repo-why-choose-one-when-you-can-have-both-e9c77bd0c668</a><br>\n<a href=\"https://levelup.gitconnected.com/moving-from-multiple-repositories-to-a-lerna-js-mono-repo-faa97aeee35b\">https://levelup.gitconnected.com/moving-from-multiple-repositories-to-a-lerna-js-mono-repo-faa97aeee35b</a></p>","frontmatter":{"path":"/posts/TIL/12","title":"Mono Repo","date":"January 17, 2020"}}},"pageContext":{}}}