{"componentChunkName":"component---src-components-templates-page-template-js","path":"/posts/TIL/7","result":{"data":{"markdownRemark":{"html":"<h1>GraphQL 이란?</h1>\n<p><code class=\"language-text\">GraphQL</code>은 클라이언트에서 서버의 데이터를 효율적으로 가져오기 위한 목적이다.\n<code class=\"language-text\">SQL</code>은 백엔드에서 데이터베이스의 데이터를 효율적으로 가져오기 위한 목적이다.</p>\n<p>서버에서 작성된 <code class=\"language-text\">gql</code> 어플리케이션은 <code class=\"language-text\">gql</code>을 쿼리로 입력받아 처리한 결과를 다시 응답으로 돌려줍니다.<code class=\"language-text\">gql</code>은 특정 데이터베이스나 플랫폼에 종속적이지 않습니다.</p>\n<h1>GrapqhQL 파이프라인</h1>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 1200px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/4a54c69725486893c1f890ced5b37581/85254/2020-01-02-18-52.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 77.9537149817296%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABYlAAAWJQFJUiTwAAABsElEQVQ4y42U6Y7CMAyEef8X5EYFUcpRbkrLafSNNFXY3R8byUpc2xPP1G3ncrnE+XyWca6qqjU/P51Ocb/fI12OX69X7fjv9zs6+/0+ns+nCgjsdjuZQYjVdR3H41FA9ql7PB6xXq+1Hw4H7QJ8vV5yttttzOfzWC6XsVgs4na7KWZAzpvNRmDkAk7+FyCdmLbbpwiQlDLgFOCzLBF57Jgo22maRhQpns1mLTVrhQ8gcWuIGZBmBEirAGVZFtPpNPr9fnS73ZhMJvIBozuAoEw+l7MDiDzEkaTVkNt5MB6PZb1eT4C8HC6jCwOuVitpSAzAPM9bjcntWAta5ibOCM6ZAutL8r81dJAiboIqXaeAJGMGJEYTqbVzyIGEwWAg/aCNlnQKTTRDY3zmztpBm4koy1JS0IQAWQQBG41GAmQvikJJ0B8Oh5o5CumGnRfDJQYWoPmThEbcTpCz9TFNa5eOzS/K1s+DTcfQ80w69nOw3QRm8FZDdMI4QwVjHADwgHts0BCqsMDwoe1vW4NtQG63JhgJfil//RzIp57Y17ds82/IvzE/pwDK6bL2qUH5AxCFzkNmTyd0AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"GrapqhQL 파이프라인\"\n        title=\"GrapqhQL 파이프라인\"\n        src=\"/static/4a54c69725486893c1f890ced5b37581/f0628/2020-01-02-18-52.png\"\n        srcset=\"/static/4a54c69725486893c1f890ced5b37581/8c2ab/2020-01-02-18-52.png 300w,\n/static/4a54c69725486893c1f890ced5b37581/3f01f/2020-01-02-18-52.png 600w,\n/static/4a54c69725486893c1f890ced5b37581/f0628/2020-01-02-18-52.png 1200w,\n/static/4a54c69725486893c1f890ced5b37581/85254/2020-01-02-18-52.png 1642w\"\n        sizes=\"(max-width: 1200px) 100vw, 1200px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<h1>REST API와 GraphQL 비교</h1>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 1200px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/5f15029cbf3642b6f5fe884f210674c7/923f8/2020-01-02-19-06.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 49.8792270531401%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAAByklEQVQoz22Ry27TQBSG8yxseQ8eogtWbLti26qiqFsED4CQEBISUpdA1HbREgRUFSpSJZLUKbZjjy8zvpT4ltie/MxMYtcBRrLHc+b48/+NexCj5lxO+HpxiYdPXuD523dqvZTXconuqOtazYcfTvBgew9H3760ddnbk7em6f3ZJ9x/9BjPXr5ZAcXe38Bq3Xvw6jXubW3j5PRsEygXfJ1QN6fYf7qPo499NPUutPvxwecBdnd2MP45/DehlONyyu3V5n9Uu+u7pwWKskQym7UVBVRIXqEOrhBnFsJFiqqTqoFVVYWiKDBflMhmMa7JD/xOEmRZhvl8roxaIC8TyJhG9h1JdYsZryVtAyhf9H0fYRTB0HX0+31QShEEARhjKEXaXquyiJRLzmMlrZWpEOIburkAUhYoALVHuDLPoVMX0bomDRQwDBmoZyOOb+F4lthksKkP1/eUYjOyPAcT9Vg7FslMjOgAN4GLS0YQB+EqofR2XQ+EOHAcAl03YJomHEJgWxYScUbNyPMCxJ7Cs29Erwv9ly7eI7ieGvA8b5VQ/u4wDBGJc7EEQNM0GIahalIjTdM7oFQWZ+ZThvF4hOFoiMlkAt91W+U/9iPypTsqj5EAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"2020 01 02 19 06\"\n        title=\"2020 01 02 19 06\"\n        src=\"/static/5f15029cbf3642b6f5fe884f210674c7/f0628/2020-01-02-19-06.png\"\n        srcset=\"/static/5f15029cbf3642b6f5fe884f210674c7/8c2ab/2020-01-02-19-06.png 300w,\n/static/5f15029cbf3642b6f5fe884f210674c7/3f01f/2020-01-02-19-06.png 600w,\n/static/5f15029cbf3642b6f5fe884f210674c7/f0628/2020-01-02-19-06.png 1200w,\n/static/5f15029cbf3642b6f5fe884f210674c7/923f8/2020-01-02-19-06.png 1656w\"\n        sizes=\"(max-width: 1200px) 100vw, 1200px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>\n<code class=\"language-text\">REST API</code>를 사용하면 엔드포인트마다 요청을 여러번 보내야 하는데, <code class=\"language-text\">GraphQL</code>은 단 하나의 요청으로 여러 데이터를 가져올 수 있다.</p>\n<h1>GraphQL의 구조</h1>\n<h2>쿼리/뮤테이션</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 1200px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/b324271b519cbf80f908f09e5074e414/0460d/2020-01-02-19-08.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 21.001221001221%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAb0lEQVQY032PjQqDMBCD+/5PKkPKYKLt/cWLomOwGgiF9mvuUlQVogZ3R0QMrV3g6SAHpP9zxczwqgu2JqB4+SOCPEQxTxXvzwrbOlzsfv+iGcgNz+0wFEEObhnSevK0DgIZBsRj3aNyDr4+P1XeAWTMPPTeQUeqAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"2020 01 02 19 08\"\n        title=\"2020 01 02 19 08\"\n        src=\"/static/b324271b519cbf80f908f09e5074e414/f0628/2020-01-02-19-08.png\"\n        srcset=\"/static/b324271b519cbf80f908f09e5074e414/8c2ab/2020-01-02-19-08.png 300w,\n/static/b324271b519cbf80f908f09e5074e414/3f01f/2020-01-02-19-08.png 600w,\n/static/b324271b519cbf80f908f09e5074e414/f0628/2020-01-02-19-08.png 1200w,\n/static/b324271b519cbf80f908f09e5074e414/0460d/2020-01-02-19-08.png 1638w\"\n        sizes=\"(max-width: 1200px) 100vw, 1200px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>\n<code class=\"language-text\">CRUD</code>중 <code class=\"language-text\">R</code>만을 담당하는것이 쿼리이고, 나머지 <code class=\"language-text\">CUD</code>를 담당하는것이 뮤테이션이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"graphql\"><pre class=\"language-graphql\"><code class=\"language-graphql\">// 일반 쿼리\n<span class=\"token punctuation\">{</span>\n  human<span class=\"token punctuation\">(</span><span class=\"token attr-name\">id</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"1000\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    name\n    height\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n// operation name <span class=\"token keyword\">query</span>\n<span class=\"token keyword\">query</span> HeroNameAndFriends<span class=\"token punctuation\">(</span><span class=\"token variable\">$episode</span><span class=\"token punctuation\">:</span> Episode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  hero<span class=\"token punctuation\">(</span><span class=\"token attr-name\">episode</span><span class=\"token punctuation\">:</span> <span class=\"token variable\">$episode</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    name\n    friends <span class=\"token punctuation\">{</span>\n      name\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>일반 쿼리와 오퍼레이션 네임 쿼리의 다른 점은 변수를 매개변수로 받느냐 마냐이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"graphql\"><pre class=\"language-graphql\"><code class=\"language-graphql\"><span class=\"token keyword\">query</span> getStudentInfomation<span class=\"token punctuation\">(</span><span class=\"token variable\">$studentId</span><span class=\"token punctuation\">:</span> ID<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  personalInfo<span class=\"token punctuation\">(</span><span class=\"token attr-name\">studentId</span><span class=\"token punctuation\">:</span> <span class=\"token variable\">$studentId</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    // 개인정보들\n  <span class=\"token punctuation\">}</span>\n  classInfo<span class=\"token punctuation\">(</span><span class=\"token attr-name\">year</span><span class=\"token punctuation\">:</span> <span class=\"token number\">2018</span><span class=\"token punctuation\">,</span> <span class=\"token attr-name\">studentId</span><span class=\"token punctuation\">:</span> <span class=\"token variable\">$studentId</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    // 수업정보들\n  <span class=\"token punctuation\">}</span>\n  SATInfo<span class=\"token punctuation\">(</span><span class=\"token attr-name\">schoolCode</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0412</span><span class=\"token punctuation\">,</span> <span class=\"token attr-name\">studentId</span><span class=\"token punctuation\">:</span> <span class=\"token variable\">$studentId</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    // <span class=\"token constant\">SAT</span>에 대한 정보들\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>REST API로 위의 3가지 정보들을 불러오려고 했다면 서버로 3번의 요청을 보내야 했을것이다.\n하지만 GraphQL에서는 위의 오퍼레이션 네임 쿼리(<code class=\"language-text\">getStudentInformation</code>)를 사용해서 단한번의 요청으로 3가지 정보들을 모두 불러올수있다.</p>\n<h1>스키마와 타입(Schema/Type)</h1>\n<p><code class=\"language-text\">REST API</code>로 백엔드와 프론트엔드 개발자가 서로 협업하려면 API 인터페이스를 먼저 작성하고 작업을 하던지 아니면 백엔드 개발자가 제공하는 request, response 형태에 맞춰 개발을 해야 했다.\n하지만, <code class=\"language-text\">GraphQL</code>을 사용하면 이런 백엔드/프론트 의존성을 줄일수 있다.(물론 GraphQL 스키마 정의에는 의존성이 여전히 존재한다.)</p>\n<p>GraphQL의 스키마를 작성하는건 C/C++에서 헤더파일을 만들어두고 CPP 파일에서 헤더를 include해서 구현하는것과 비슷하다.</p>\n<h2>오브젝트 타입과 필드</h2>\n<div class=\"gatsby-highlight\" data-language=\"graphql\"><pre class=\"language-graphql\"><code class=\"language-graphql\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Character</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token attr-name\">name</span><span class=\"token punctuation\">:</span> String<span class=\"token operator\">!</span>\n  <span class=\"token attr-name\">appearsIn</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>Episode<span class=\"token operator\">!</span><span class=\"token punctuation\">]</span><span class=\"token operator\">!</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ol>\n<li>Character라고 하는 객체 타입을 정의했다.</li>\n<li>이 객체 안에는 name, appearsIn 두개의 필드가 존재한다.</li>\n<li>name 필드는 String 스칼라 타입이다.</li>\n<li>name 필드는 필수값이다(!)</li>\n<li>appearsIn필드는 Episode 스칼라 타입의 배열이며 이 배열도 필수로 존재해야하고, 배열내의 적어도 하나의 Episode가 있어야 한다.</li>\n</ol>\n<h1>리졸버(resolver)</h1>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 1200px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/4a54c69725486893c1f890ced5b37581/85254/2020-01-02-18-52.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 77.9537149817296%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABYlAAAWJQFJUiTwAAABsElEQVQ4y42U6Y7CMAyEef8X5EYFUcpRbkrLafSNNFXY3R8byUpc2xPP1G3ncrnE+XyWca6qqjU/P51Ocb/fI12OX69X7fjv9zs6+/0+ns+nCgjsdjuZQYjVdR3H41FA9ql7PB6xXq+1Hw4H7QJ8vV5yttttzOfzWC6XsVgs4na7KWZAzpvNRmDkAk7+FyCdmLbbpwiQlDLgFOCzLBF57Jgo22maRhQpns1mLTVrhQ8gcWuIGZBmBEirAGVZFtPpNPr9fnS73ZhMJvIBozuAoEw+l7MDiDzEkaTVkNt5MB6PZb1eT4C8HC6jCwOuVitpSAzAPM9bjcntWAta5ibOCM6ZAutL8r81dJAiboIqXaeAJGMGJEYTqbVzyIGEwWAg/aCNlnQKTTRDY3zmztpBm4koy1JS0IQAWQQBG41GAmQvikJJ0B8Oh5o5CumGnRfDJQYWoPmThEbcTpCz9TFNa5eOzS/K1s+DTcfQ80w69nOw3QRm8FZDdMI4QwVjHADwgHts0BCqsMDwoe1vW4NtQG63JhgJfil//RzIp57Y17ds82/IvzE/pwDK6bL2qUH5AxCFzkNmTyd0AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"GrapqhQL 파이프라인\"\n        title=\"GrapqhQL 파이프라인\"\n        src=\"/static/4a54c69725486893c1f890ced5b37581/f0628/2020-01-02-18-52.png\"\n        srcset=\"/static/4a54c69725486893c1f890ced5b37581/8c2ab/2020-01-02-18-52.png 300w,\n/static/4a54c69725486893c1f890ced5b37581/3f01f/2020-01-02-18-52.png 600w,\n/static/4a54c69725486893c1f890ced5b37581/f0628/2020-01-02-18-52.png 1200w,\n/static/4a54c69725486893c1f890ced5b37581/85254/2020-01-02-18-52.png 1642w\"\n        sizes=\"(max-width: 1200px) 100vw, 1200px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>\n아까 살펴봤던 <code class=\"language-text\">GraphQL 파이프라인</code>을 한번더 다시 보자.\n<code class=\"language-text\">GraphQL쿼리</code>는 파싱되어 <code class=\"language-text\">리졸버</code>로 들어가게된다. 한마디로 <code class=\"language-text\">리졸버</code>는 <code class=\"language-text\">GraphQL</code>에서 실제로 데이터 처리를 담당하는 친구이다.\n이것은 개발자가 직접 구현해야 하며, 개발자가 원하는 방식대로 구현할수있고 자신이 원하는 데이터베이스를 사용해서 데이터 가져오는 로직을 작성할 수 있다.\n그렇기 때문에 데이터를 RDB에서 가져올수도 있고 파일에서 가져올수도 있고 심지어 다른 네트워크 통신을 통해서 가져올 수도있다.</p>\n<p>한마디로, <code class=\"language-text\">GraphQL</code> 쿼리문 자체는 인터페이스라고 생각하면 편한것같다.</p>\n<h2>GraphQL의 쿼리문이 처리되는 과정</h2>\n<p>다음과 같은 GraphQL 쿼리문이 서버로 도착했다고 가정하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"graphql\"><pre class=\"language-graphql\"><code class=\"language-graphql\"><span class=\"token keyword\">query</span> HeroNameAndFriends<span class=\"token punctuation\">(</span><span class=\"token variable\">$episode</span><span class=\"token punctuation\">:</span> Episode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  hero<span class=\"token punctuation\">(</span><span class=\"token attr-name\">episode</span><span class=\"token punctuation\">:</span> <span class=\"token variable\">$episode</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    name\n    friends <span class=\"token punctuation\">{</span>\n      name\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>구조를 먼저 살펴보면, <code class=\"language-text\">hero</code>라고 하는 필드가 있고 하위에 <code class=\"language-text\">name</code>, <code class=\"language-text\">friends</code> 서브 필드가 있으며 <code class=\"language-text\">friends</code>서브 필드에는 <code class=\"language-text\">name</code>이라는 서브서브필드가 있다.\n이 쿼리문은 파싱되어 리졸버에게 전달된다.</p>\n<p>리졸버의 역할은 각 필드에 해당하는 데이터를 실제로 내주는것이다.\n필드 1개당 리졸버 1개가 존재한다. 만약에 리졸버가 스칼라값(문자열이나 숫자)를 리턴한다면 리졸버의 호출이 종료된다.\n스칼라값을 만나기 전까지 리졸버는 계속 실행된다. 즉 <code class=\"language-text\">GraphQL</code>은 알고리즘에서 <code class=\"language-text\">DFS</code>로 구현되어 있지 않을까 추측된다. 끝장을 보기 전까지는 계속해서 파고든다.</p>\n<h2>리졸버를 제대로 활용해보자.</h2>\n<div class=\"gatsby-highlight\" data-language=\"graphql\"><pre class=\"language-graphql\"><code class=\"language-graphql\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">{</span>\n  // 유저에 대한 필드\n  <span class=\"token attr-name\">name</span><span class=\"token punctuation\">:</span> String<span class=\"token operator\">!</span>\n  <span class=\"token attr-name\">phoneNumber</span><span class=\"token punctuation\">:</span> String<span class=\"token operator\">!</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Limit</span> <span class=\"token punctuation\">{</span>\n  // 유저 <span class=\"token number\">1</span>명이 가질수 있는 제한\n  <span class=\"token attr-name\">id</span><span class=\"token punctuation\">:</span> ID<span class=\"token operator\">!</span>\n  <span class=\"token attr-name\">amout</span><span class=\"token punctuation\">:</span> Int\n  <span class=\"token attr-name\">user</span><span class=\"token punctuation\">:</span> User\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Payment</span> <span class=\"token punctuation\">{</span>\n  // 유저 <span class=\"token number\">1</span>명이 지불한 지불정보들\n  <span class=\"token attr-name\">limit</span><span class=\"token punctuation\">:</span> Limit<span class=\"token operator\">!</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>User, Limit, Payment라고하는 3개의 오브젝트 타입이 존재한다.\n유저는 1개의 제한만을 가질수 있고, 여러개의 지불정보를 가질 수 있다.\n이 상황에 다음과 같이 쿼리문이 들어왔다고 해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"graphql\"><pre class=\"language-graphql\"><code class=\"language-graphql\"><span class=\"token punctuation\">{</span>\n  paymentsByUser<span class=\"token punctuation\">(</span><span class=\"token attr-name\">userId</span><span class=\"token punctuation\">:</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    id\n    amount\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">{</span>\n  paymentsByUser<span class=\"token punctuation\">(</span><span class=\"token attr-name\">userId</span><span class=\"token punctuation\">:</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    id\n    amount\n    user <span class=\"token punctuation\">{</span>\n      name\n      phoneNumber\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>대충 어떤식으로 동작할지 감이 오는가?\n위 두개의 쿼리는 동일한 쿼리명을 갖고 있지만 아래 쿼리문이 더 많은 리졸버를 호출한다.\n아래 쿼리문에서는 id, amount, user 3개의 필드를 갖고 있는데 id와 amout 필드 담당인 리졸버는 스칼라값을 리턴하고 종료되지만, 마지막 user필드에 대해서는 한번더 파고들어서\nuser의 name과 phoneNumber리졸버 까지 호출하게 된다.</p>\n<p>그에반해, 위의 쿼리는 id, amount 두 필드에 해당하는 리졸버만 호출하게 된다.</p>\n<p>리졸버 함수는 다음과 같이 구현하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"graphql\"><pre class=\"language-graphql\"><code class=\"language-graphql\">  <span class=\"token punctuation\">{</span>\n    paymentsByUser<span class=\"token punctuation\">(</span><span class=\"token attr-name\">userId</span><span class=\"token punctuation\">:</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> // 리졸버 명세\n      id\n      amount\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token attr-name\">Query</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token attr-name\">paymentsByUser</span><span class=\"token punctuation\">:</span> async <span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> userId <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> context<span class=\"token punctuation\">,</span> info<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span>> <span class=\"token punctuation\">{</span> // 리졸버 구현\n        const limit <span class=\"token operator\">=</span> await Limit.findOne<span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token attr-name\">where</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token attr-name\">UserId</span><span class=\"token punctuation\">:</span> userId <span class=\"token punctuation\">}</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n        const payments <span class=\"token operator\">=</span> await Payment.findAll<span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token attr-name\">where</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token attr-name\">LimitId</span><span class=\"token punctuation\">:</span> limit.id <span class=\"token punctuation\">}</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n        return payments\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<p>이름 없는 GraphQL 쿼리의 paymentsByUser라고 하는 필드를 아까 정의 했었고 아래에서는 그 필드를 실제로 가져오기 위한 리졸버를 실제로 구현하고 있다. 마치 위의 인터페이스를 아래에서 구현하고 있는듯한 느낌이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"graphql\"><pre class=\"language-graphql\"><code class=\"language-graphql\">  <span class=\"token attr-name\">Query</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token attr-name\">paymentsByUser</span><span class=\"token punctuation\">:</span> async <span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> userId <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> context<span class=\"token punctuation\">,</span> info<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span>> <span class=\"token punctuation\">{</span> // 리졸버 구현\n        const limit <span class=\"token operator\">=</span> await Limit.findOne<span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token attr-name\">where</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token attr-name\">UserId</span><span class=\"token punctuation\">:</span> userId <span class=\"token punctuation\">}</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n        const payments <span class=\"token operator\">=</span> await Payment.findAll<span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token attr-name\">where</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token attr-name\">LimitId</span><span class=\"token punctuation\">:</span> limit.id <span class=\"token punctuation\">}</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n        return payments\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<p>그래서 이 쿼리 부분을 자세히 살펴보자. 총 4개의 인자를 받고있다.</p>\n<ul>\n<li>\n<p>첫번째 인자는 부모 리졸버가 최종적으로 리턴한 값이 들어온다.</p>\n<p><strong>(아까 paymentsByUser쿼리문에서 user필드를 만났을때 계속해서 파고든다고 했는데 사실은 부모 리졸버는 종료되고 자식 리졸버가 대를 이어 계속 파고 드는것 같다.)</strong></p>\n</li>\n<li>두번째 인자는 쿼리문에 넘겼던 매개변수(<code class=\"language-text\">userId</code>)가 들어온다.</li>\n<li>세번째 인자는 모든 리졸버가 공통으로 사용하는 <code class=\"language-text\">context</code>가 들어오는데, 보통 미들웨어를 거쳐서 입력된 로그인과 같은 정보들이 들어온다.</li>\n<li>네번째 인자는 스키마 정보나 필드 정보등이 들어있다.(잘 사용되지 않음.)</li>\n</ul>\n<h1>인트로스펙션(introspection)</h1>\n<p>프론트와 백엔드가 협업하기 전에 API 인터페이스를 먼저 작성하고 작업에 들어간다. 그렇게 하지 않으면 API가 개발될때까지 프론트 개발이 지연되기 때문이다.\n그런데, 이렇게 API 인터페이스 문서를 작성하는것도 문제이다. 왜냐면, 이 문서 자체도 계속해서 업데이트를 해줘야하는데 이게 한두개 API가 있을땐 괜찮은데\nAPI가 많아지다보면 이 문서 자체를 관리하기 쉽지가 않다.</p>\n<p>GraphQL의 인트로스펙션 기능을 사용하면 현재 서버에 저장된 스키마의 정보를 실시간으로 확인할수있다.\n그러니까 문서를 따로 만들필요가 없는것이다. 백엔드개발자가 스키마를 정의해주면 프론트엔드개발자는 그걸 실시간으로 확인해서 개발하면 된다.\n다시말해서, 스키마만 정의되면 프로젝트를 병렬적으로 작업할 수 있다는 얘기고 이건 생산성 향상에 큰 효과가 있다는것을 의미한다.</p>\n<p>GraphQL을 서버에서 사용하기 위해서는 apollo server라는 라이브러리를 사용하는데 여기서 기본적으로 제공하는 웹 IDE에서 현재 실시간 스키마 정보를 확인할 수 있다.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 1200px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/579c528476e34717700809a135f6589b/d6810/2020-01-02-20-13.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 63.04062909567497%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAACh0lEQVQ4y42TSW/TUBSFvQOEkNqStrFTp3YTO3Zsx246JU1nkNiUNUJiwxaJv4BQu2BY0G5ggdhXaqk6MHSBxIL/woJN08GJZx+unTRUDBKWjq6f33ufz733PWau1sDiwgrmFpfRmF+GYVZRlBRIsgqJ4sW7ohowDAuGlkQTemUSelmHSd/0SjWd03QTjGzNQq3OQrHqUHQLomIhLxsYKWgYkS0INObGVAzlSxhVJyAUNQiyBrZooqBUIRbLkMomeEmnfTqYvN5AYXwBQ8VxsAUdfHkaWWkcGUHHsDSB66yMB48e4+jLV2zvfcbuYaIjbO8eYPv9PsVdHHz4hJ39j9jZOwTDKVPoz6uo3VrF6r2HyNGY1+pglRp4+tmV4RKevXmN/30YyZjEmGpifmkVt+/eR7Y0BXHyDoTqCkRrCRmaf/dtC6Hrw2614DgO2u02Tk/P4LQdBEGAMAx7YrJyBdmCgb5cCQOihZw2C05rgK/UIVhz6JNNbGy9BTwb9nkTruulwLNzG07LBiIPMTmL4xhRFIHJCBoGRsvIiBo4ZQacWqN0Z1LxBL6aVfH05SvaEiFw293EYnLqokkuA+eMhhEB0QHeTGBCIuocpZsAL5TU8BpXxvrmBkE8uM0fCDwXURynqduOD5diHPo9l6nDDvQXkO067QBVrG0kwADe6XfEvp1uTNJGz29K6zTlX0BWnekAWRXrKTCE0zxG0DpB6LvUjDAF93TZ4YWyl4HKJWCaMuBT3SI/6WrUA/wuZoDOYOIwEatME7Deq2G+W8O1zc0U6LTttDmdJsR/P4fJ9RpMmjKqom+Ejg6vor+rQZGu0g0OT148TxefnxzDo5Rdkue68H3/D/0EEOyQSByNzGgAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"2020 01 02 20 13\"\n        title=\"2020 01 02 20 13\"\n        src=\"/static/579c528476e34717700809a135f6589b/f0628/2020-01-02-20-13.png\"\n        srcset=\"/static/579c528476e34717700809a135f6589b/8c2ab/2020-01-02-20-13.png 300w,\n/static/579c528476e34717700809a135f6589b/3f01f/2020-01-02-20-13.png 600w,\n/static/579c528476e34717700809a135f6589b/f0628/2020-01-02-20-13.png 1200w,\n/static/579c528476e34717700809a135f6589b/d6810/2020-01-02-20-13.png 1526w\"\n        sizes=\"(max-width: 1200px) 100vw, 1200px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<h1>GraphQL로 비즈니스 로직 작성하기</h1>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 1200px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/f81a6d74079f5272728b51bdaefbafdb/542a1/2020-01-02-20-19.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 89.35309973045821%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAABYlAAAWJQFJUiTwAAADPElEQVQ4y6WO2U8TYRTFvz/C+GZMXMKDiVHAhUUWCSpgwDW2QnENiIBawagJGBeIok9u0QguKApKkQ7QYstSZqqRtrQFZFNIBDURfaa0LuF455tpRUx88eGXc+79zrkzrFhMwjFbHOd4VyKRgCOdMXB+bsUlZzbyO9agoDOK7+RMYWc0PF86UNat4Xs95fVd8Rz5nRWLyZC5038aNzxHUfpqC5Vi4KCDV1wHUOHch5ve47jdewJXPYUooo+66WB5dyYdjMYt2l/zFPCf0RPsmG01PYTjhBSPIjGGjkUir305eiabUe7YweeSVyk4ZV+Pk0R+x0r0frXg3Ot05LYto04sHYumGxHESrDaESOeDNejZvgpHg8/415W1+QYjGMWPBqqQ40MvdfQXn5zT77H81EzeaUjay3vNYCd7XiDMWkP3tkPEgdCDHTtxkhXJkZFHd6J2YROJRtvbFq8lfZhVM2OSDn4ZNfgensTHbS04Ju4ENPiUpUlnIAUhoBzIwLu7Qi4UhHoyVB9GgL2ZfCLi0PZKTEMkOaj8kUFWJnVTMMCzNgXY0Yi7IsAzhLAGQu4EgFHFGk80JOk7F4u5Rk5OyMtwg+J5pfzUG29DJbbOohqy0U+VFsrOHfpS1XE3dYyVJkv4B5pJWml+Tz3VS8u8Uwwf996BXXW89CbbGAbWr4jvBFYZQQiSFcLgM6moOkE9opAmgXItP32Wtpn0bxWUDqRcpeIMv4ESzVNI844hQRhCvGCohmtPuy0+JBuVjTV5IO2zQeNVfGybqXM7I7ifWApJj9ijXRUUFhHPrpxGlFETFBpt3aWl1XOrAv2ZvVZmklZJAi/SZxDwj/8XFic4McKwzTCGwjD/8PKnX6UvPbjDFE6izPdgX9SOicfhH0sNmPisIAPBU0hJvIFjOc0YvyQUSFX8RN5hDrP7QRhPVuewJH0AI7kagXyztRH6NvfCI/2Gby76+HVNcBD6t5WC4+GdlkGuDbX/NlTYd4ddXBvegg3HeGkPIQn4zEGDzdj4KCRtAlD+c0YzGtCv86AYb0ZQ4Ut8NKPyNlQT4UN5Ajoz6zn4f4sFZr7dj1FH/0NZ5eq2vrQzDtZhr/4BST+DNe9a4jJAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"2020 01 02 20 19\"\n        title=\"2020 01 02 20 19\"\n        src=\"/static/f81a6d74079f5272728b51bdaefbafdb/f0628/2020-01-02-20-19.png\"\n        srcset=\"/static/f81a6d74079f5272728b51bdaefbafdb/8c2ab/2020-01-02-20-19.png 300w,\n/static/f81a6d74079f5272728b51bdaefbafdb/3f01f/2020-01-02-20-19.png 600w,\n/static/f81a6d74079f5272728b51bdaefbafdb/f0628/2020-01-02-20-19.png 1200w,\n/static/f81a6d74079f5272728b51bdaefbafdb/542a1/2020-01-02-20-19.png 1484w\"\n        sizes=\"(max-width: 1200px) 100vw, 1200px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>\n비즈니스 로직 자체는 graphql 리졸버에 담아서는 안된다. 이 로직은 비즈니스 로직 레이어에 작성을 하고 리졸버에서는 그 레이어에 작성한 함수를 호출해서 응답을 내주는 역할만을 해야 한다.\n예시를 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"graphql\"><pre class=\"language-graphql\"><code class=\"language-graphql\">    <span class=\"token attr-name\">requestPaymentSession</span><span class=\"token punctuation\">:</span> async <span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n      pgId<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">,</span> sex<span class=\"token punctuation\">,</span> birthDay<span class=\"token punctuation\">,</span> phoneNumber<span class=\"token punctuation\">,</span> amount<span class=\"token punctuation\">,</span> productName<span class=\"token punctuation\">,</span> ref\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> context<span class=\"token punctuation\">,</span> info<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span>> <span class=\"token punctuation\">{</span>\n      const ret <span class=\"token operator\">=</span> await requestPaymentSession<span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> pgId<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">,</span> birthDay<span class=\"token punctuation\">,</span> phoneNumber<span class=\"token punctuation\">,</span> sex<span class=\"token punctuation\">,</span> amount<span class=\"token punctuation\">,</span> productName<span class=\"token punctuation\">,</span> ref <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n      return removeSymbol<span class=\"token punctuation\">(</span>ret<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token attr-name\">requestPaymentApprove</span><span class=\"token punctuation\">:</span> async <span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n      sessionKey<span class=\"token punctuation\">,</span> authNumber\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> context<span class=\"token punctuation\">,</span> info<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span>> <span class=\"token punctuation\">{</span>\n      const ret <span class=\"token operator\">=</span> await requestApprovePayment<span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> sessionKey<span class=\"token punctuation\">,</span> authNumber <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n      return removeSymbol<span class=\"token punctuation\">(</span>ret<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">requestPaymentSession</code>과 <code class=\"language-text\">requestPaymentApprove</code>라는 두개의 리졸버를 정의했다. 각 리졸버는 비즈니스 레이어에 정의한 함수를 호출하여 응답을 내주고 있다.</p>\n<h1>정리</h1>\n<p>GraphQL은 퍼포먼스적인 장점도 있지만, 생산성 향상 측면을 더 주목해야한다.\n기존 백엔드 - 프론트 협업 문화를 많이 바꿀것이다. 프론트엔드쪽의 할일이 더 많아지는것 같지만 애자일하게 프로젝트를 진행하는데 많은 도움이 될 것 같다.\n왜냐면, API 명세서를 쉽고 빠르게 공유할수 있으며 관리하기도 편하기 때문에, 서비스를 더욱더 빨리빨리 만들어낼수있기 때문이다.</p>\n<h3>출처</h3>\n<p><a href=\"https://tech.kakao.com/2019/08/01/graphql-basic/\">카카오 Tech : GraphQL 개념잡기</a></p>","frontmatter":{"path":"/posts/TIL/7","title":"GraphQL개론","date":"January 02, 2020"}}},"pageContext":{}}}