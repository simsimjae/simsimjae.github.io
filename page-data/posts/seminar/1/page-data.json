{"componentChunkName":"component---src-components-templates-page-template-js","path":"/posts/seminar/1","result":{"data":{"markdownRemark":{"html":"<h1>원티드 AB테스트</h1>\n<p>원티드는 <code class=\"language-text\">가설</code> <code class=\"language-text\">테스트</code> <code class=\"language-text\">검증</code> 3가지 단계로 프로덕트를 개선한다.</p>\n<p>가설이라는건 사람마다 다르게 생각하고 결과 예측도 사람마다 다 다르게 한다. 남을 설득하거나 설득 당할수 있다. 경험이나 감만으로 결과를 예측하는것은 위험하다.</p>\n<p>테스트 단계에서 프론트엔드 개발팀이 기여했던 경험에 대해서 얘기해보겠다.</p>\n<h2>회원가입전환룰 높이기위해 진행한 ab테스트</h2>\n<p>채용공고 신규 유저 화원가입 전환률 높이기</p>\n<ol>\n<li><strong>채용공고를 보기전</strong> 회원가입 유도 (a)</li>\n<li><strong>채용공고는 보여주고</strong> 추가적인 액션시 유도 (b)</li>\n</ol>\n<p>1번 - 메인화면의 잡카드를 클릭시 상세로 넘어가지 않고 로그인창 띄우기</p>\n<p>2번 - 상세에서 채용공고는 보여주고 <code class=\"language-text\">공유하기</code>, <code class=\"language-text\">지원하기</code>버튼 클릭과 같은 적극적인 액션시 로그인창 띄우기</p>\n<p>결과를 먼저 얘기하면, <strong>AB테스트로 회원가입 전환률 2.5배 상승 효과가 있었다.</strong> 테스트 하기전엔 두가지 안 모두 그럴듯해보였지만, 테스트 후 큰 결과의 차이를 가져왔다.</p>\n<p>구글의 gtag라는 라이브러리 사용(유료)하여 컴포넌트가 마운트 되었을때 콜백함수에서 실험의 번호와 이름을 인자로 받아서 각 실험에 대한 분기처리를 해줄 수 있다.\n실험 페이지에 접속한 유저중 몇퍼센트 유저에게만 실험을 진행할건지 각 대안 AB의 가중치는 어떻게 할건지 등을 정할 수 있다. 어떤 페이지를 실험할건지도 정할 수 있다.\n개발자의 적극적인 노력이 실제로 사업에 도움이 된 겅우를 원티드의 사례였다.</p>\n<p>개발을 가장 중요시하지만 UI/UX, 테스트, 제품개선의지 등도 중요시해야 좋은 제품을 만들 수 있다</p>\n<h2>라이브코딩</h2>\n<p>위 사진은 현장에서 진행된 라이브 코딩 예시용 프로젝트이다.</p>\n<p>사이트에 접속한 유저중,</p>\n<p><code class=\"language-text\">A테스트 유저</code>에겐 최우식 사진을 보여주고</p>\n<p><code class=\"language-text\">B테스트 유저</code>에겐 펭수 사진을 보여준다.</p>\n<p>어떤 사진이 더 유저의 반응을 이끌어낼 수 있을지 테스트 하기 위한 예시</p>\n<h2>원티드의 기술 스택</h2>\n<ul>\n<li>전부 리액트로 구성 공통 요소는 <code class=\"language-text\">리액트 리덕스 웹팩</code>이다</li>\n<li>ssr(<code class=\"language-text\">서버사이드렌더링</code>)을 위해 <code class=\"language-text\">넥스트</code> 사용</li>\n<li>일부에서 <code class=\"language-text\">타입스크립트</code> 점진 도입중, <code class=\"language-text\">RxJs</code>는 레거시</li>\n</ul>\n<p>사스를 기본적으로 사용하되, 동적 데이터 처리에는 <code class=\"language-text\">스타일드 컴포넌트</code>를 사용한다. <code class=\"language-text\">지라</code>를 통해서 이슈 관리 한다.</p>\n<p>티켓 담당자 할당 → 깃 브랜치 생성 → 작업 완료 → Pull Request → Develop branch merge → CI/CD를 통한 EC2 자동 배포 (<code class=\"language-text\">번역파일</code> 및 <code class=\"language-text\">static resources</code>는 s3사용)</p>\n<p>Pull Request를 통해서 코드리뷰를 진행하고, 기존 소스 영향도 체크 및 잠재적 버그를 예측한다.</p>\n<p>원티드는 총 4개의 도메인을 사용하는데 각 영역의 기술스택이 통일되어있지 않지만, 점진적으로 개선해나가는 중이고 스택 통일로인한 도메인 스윗칭 비용 감소 효과를 기대중이다.</p>\n<h2>Q&#x26;A</h2>\n<h3>Q. 서버사이드렌더링시 ab테스트 어떻게 진행해야 하는가?</h3>\n<p>질문 상세 : 유저의 액션이 있을때 테스트하는게 아니라 페이지에 처음 접속했을때 UI 배치를 변경해서 어떤 UI가 더 좋은지 테스트를 하기 위해서는 서버사이드렌더링시 AB테스트를 적용해야 할거같은데 그럴땐 어떻게 해야 하는가?</p>\n<h3>A.</h3>\n<p>아직까지는 그런 테스트가 필요하지 않았다. 지금까지는 유저의 액션에 따라서 테스트를 진행하는 경우만 있었어서 컴포넌트가 마운트 된 다음에 테스트를 해왔다.</p>\n<h3>Q. 테스트 코드가 길어지면 그 코드에 대한 관리는 어떻게 하고 있는가?</h3>\n<h3>A.</h3>\n<p>지라 티켓과 커밋을 별도로 생성해서 한번에 revert하면 좋겠지만 그렇지 못한 경우가 많아서 별도로 제거 티켓을 받아서 한번에 몰아서 진행하는 편이다.</p>\n<p>테스트 코드는 우선 두개의 안 중 더 괜찮은 안을 먼저 구현한다음에 완성되고 나서 테스트 코드를 작성하고 있다. 기획단계에서부터 AB테스트 도입에 대한 고려를 한다.</p>\n<p>테스는 보통 2~3주 혹은 두세달정도 걸린다.</p>\n<p>이 api는 유료이다. 가격은 잘 모르겠다. 일정 사용량까지 무료</p>\n<h1>배달의 민족 : 디자인 시스템</h1>\n<h2>발표자 : 우아한형제들 김민태</h2>\n<p>프론트엔드 개발자의 일하는 방식에있어 우형은 어떤 시도들을 하고있나에 대해서 얘기해보겠다.</p>\n<p>준비를 거의 이년동안했고 두세달전부터 디자인 시스템 프로덕션 릴리즈 준비중이다.</p>\n<h3>일반적인 개발 워크 플로우</h3>\n<p><code class=\"language-text\">기획</code> <code class=\"language-text\">디자인</code> <code class=\"language-text\">프론트개발 백엔드개발</code> <code class=\"language-text\">기능QA 디자인QA</code> <code class=\"language-text\">릴리즈</code></p>\n<h3>위처럼 반복되는 워크플로우들을 디자인 시스템으로 개선 해보자.</h3>\n<p>개선을 하게 된 배경에는 두가지 이유가 있다.</p>\n<h3>1. 반복되는 롤백</h3>\n<p>디자이너의 의도를 프론트 개발자가 잘 파악하지 못해서 실제 결과와 디자인 사이의 조금씩 차이가 생긴다. 이런일이 생기는 이유는 디자이너는 비트맵을 생산하기 때문에 실제 워킹되는 상황에서의 다양한 상황을 상상하기 힘들기 떄문이다.</p>\n<p>또한, 어떤 부분을 중요하게 생각하는가에 대한 개발자와 디자이너의 차이 때문에 디자인결과와 실제 코딩된 결과가 차이가 있을 수 밖에없다.</p>\n<p>어떤경우엔, 디자이너가 실제로 돌아가는 화면을 보니 마음에 안들어서 다시 디자인 재검토 혹은 심지어 기획 재검토까지 하는 일이 다반사이다. 이런 경우에 서로 더 나은 대안이 있다는걸 알지만 오픈 일정 압박때문에 우선 배포를 하고 나중엔 잘하자고 결심하지만 또 같은 일이 반복된다.</p>\n<p><code class=\"language-text\">기획</code> <code class=\"language-text\">디자인</code> <code class=\"language-text\">프론트개발 백엔드개발</code> <code class=\"language-text\">기능QA 디자인QA</code> <code class=\"language-text\">릴리즈</code></p>\n<p>이 단계에서, 디자인QA단계를 없애기만해도 이 프로세스에 굉장히 큰 효율성을 가져다 줄 수 있다.</p>\n<p>디자이너가 디자인 할떄부터 실제 코드로 작동하는 컴포넌트를 가지고 하기떄문에 다시 롤백되는 일이 현저히 줄어들어든다.</p>\n<h3>2. 컴포넌트 라이프 사이클 문제</h3>\n<p>미세 하게 달라진 컴포넌트</p>\n<p>문서는 쓰는 순간부터 낡는다는 말이 있다. 이처럼 큰 규모의 앱도 마찬가지이다. 유저가 자주 많이 사용하는 페이지는 계속해서 개선되지만 그렇지 못한 페이지는 예전 그대로 낡아간다.</p>\n<p>예를 들어 배민에서 프로필 수정 화면은 다른 화면들에 비해서 계속 낡아가고있다.</p>\n<p>각 영역에 같은 컴포넌트가 들어가는데, 이 컴포넌트가 영역마다 미세하게 달라지는 일이 생겼다. 이걸 수동으로 관리하다보니 관리가 매우 어려웠다. 각 영역마다 디자이너, 개발자, 기획자가 모두 다르다 보니 생긴 문제였다. 프론트엔드 팀에게 이 문제를 해결하라는 지시가 떨어졌다.</p>\n<p>페이지의 룩을 바꾸기 위해선 생각보다 큰 코스트가 발생한다. 로직 자체는 그대로 사용한다고 해도 그렇다. 디자이너는 몇번 없을 개편에 최대한 많은것을 넣고 싶어하고 욕심이 있어서 스펙이 커진다.</p>\n<h2>디자인 시스템 해외 사례</h2>\n<p><code class=\"language-text\">에어비엔비</code> - 굉장히 잘 되어있고, 도구들이 오픈소스로 잘 공유되어있다. 선구자로서 어떤걸 해야하고 어떤 장벽이 있는지 잘 정리 되어 있어서, 우리도 레퍼런스로 삼아서 보고 있다.</p>\n<p><code class=\"language-text\">Material Design</code></p>\n<p><code class=\"language-text\">Spotify</code></p>\n<p>해외사례를 그대로 우리 회사에 적용하는거 자체가 하드한 일이고, 성공한다는 보장도 없다. 회사마다 사정이 다르기 때문이다.</p>\n<p>디자인 시스템의 필요성에 대해서 모두의 합의를 이끌어내는 과정도 힘들었다.</p>\n<p>사내 프레이머X 교육, 프로토타입작성 등을 통해 공감대를 어느정도 이끌어 낸뒤, 시작할 수 있었다.</p>\n<p>디자인 시스템은 적용을 위해 2~3년이 걸리며 조직의 전폭적인 지원이 있어야하고 실패하기 쉬운 개발 외적인 이슈들이 굉장히 많다. 그래서 우리는 점진적으로 도입하고 있다.</p>\n<h3>배민의 디자인 시스템 구조</h3>\n<ul>\n<li>디자이너가 디자인하는 순간 실제 컴포넌트를 기반으로 디자인한다.</li>\n<li>스케치로 디자인을 하고 코드로 내보낼 수 있다.( 내보내면 디자인 시스템의 일부가 되는거같음 ) 디자이너는 디자인 코드로 보고 개발자는 개발자 코드로 보기 위해 중간에 <code class=\"language-text\">Meta Lang</code>이라는것을 넣었다.</li>\n<li>에어비엔비의 SDK를 스케치에서 사용해서 디자인 시스템에 있는 컴포넌트들을 스케치에서 브라우징 해볼수도 있다. (디자인 시스템과 스케치앱 사이 변환)</li>\n<li><code class=\"language-text\">Meta Lang</code> → <code class=\"language-text\">리액트 컴포넌트</code> 자동 변환은 아직 구현하지 못했다. 지금은 팀을 만들어서 수동으로 하고 있다.</li>\n<li>변환을 한뒤에 <code class=\"language-text\">NPM Private Repository</code>에 퍼블리싱 해두면 <code class=\"language-text\">프레이머X</code>, <code class=\"language-text\">스토리북</code>, <code class=\"language-text\">APP</code>등에서 <code class=\"language-text\">import</code>해서 데이터를 입히는등 사용한다.</li>\n<li>스케치만 가지고선, 실제 환경에서 돌아가는 디자인 상태를 볼 수 없어서 <code class=\"language-text\">스토리북</code>으로 퍼블리싱해서 실제 환경에서 볼 수 있도록 구성했다.</li>\n</ul>\n<p>스케치가 디자인에서 대세가 되면서, 원래는 바이너리 파일로 내보내졌던것들이 <code class=\"language-text\">JSON</code>포맷으로 변경되었다. 그떄부터 스케치에 여러가지 플러그인들이 생겨서 <code class=\"language-text\">Meta Lang</code>을 만들어서 이런 디자인 시스템을 구성할 수 있었다.</p>\n<p>스케치의 포맷이 JSON으로 변경된것이 굉장히 큰 변화였다.</p>\n<p><code class=\"language-text\">요약</code></p>\n<p><code class=\"language-text\">디자인</code> → <code class=\"language-text\">JSON으로 내보내기</code> → <code class=\"language-text\">Meta Lang</code> → <code class=\"language-text\">리액트 코드</code>로 변경.</p>\n<p>이런 과정을 자동화 함으로써, 위에서 말한 두가지 문제를 해결해 나가고 있다.</p>\n<p>디자인 시스템에서의 디자인 컴포넌트가 변경되면 위 과정을 거쳐 import시 새롭게 업데이트된 컴포넌트가 자동으로 리액트 컴포넌트도 업데이트 되기 때문이다.</p>\n<p>디자인 팀에서도 디자인 시스템으로 만들어진 컴포넌트가 60%정도 되었다. 40%만 하면 되겠네라고 생각하겠지만 만들다보니 <code class=\"language-text\">Presentational Compoent</code>가 아니라 <code class=\"language-text\">Container Component</code>로 빼야하네? 와 같은 일들이 자주 발생했다.</p>\n<h1>토스 : 마이크로프론트엔드 아키텍쳐와 자동화</h1>\n<h3>토스 박서진 개발자</h3>\n<p><code class=\"language-text\">가설</code> <code class=\"language-text\">개발</code> <code class=\"language-text\">배포</code> - 애자일 방법론 사용.</p>\n<p>유저는 데이터를 기반으로만 이해할 수 있다.</p>\n<p>최대한 빨리 개발해서 빠르고 잦은 실험과 작은 실패를 장려하는것이 좋다.</p>\n<p>네이티브 개발로는 어려움이 많다.</p>\n<p>네이티브는 개발을 한다음에 앱 번들을 빌드하고 앱스토어에 심사를 올려야한다. 배포된 이후에도 많은 사용자들이 앱을 업데이트할때까지 기다려야한다. 이런점은 애자일 방법론과는 잘 맞지 않는다. 잦은 실험과 작은 실패를 해야하는데, 네이티브 개발은 애자일 방법론에 조금 방해되는 요소가 있었다.</p>\n<p>사용자의 반응을 빠르게 확인해서 빠르게 제품을 개선해야했다.</p>\n<p>그래서 앱안에서 웹뷰로 빠르게 서비스를 개발해 나갔다. 네이티브보다 성능적으로 손해를 보더라도 위 요소들이 더 중요하다고 생각했다. 리액트와 타입스크립트를 기반으로 앱내 웹앱을 개발해 나가고 있다. 토스에서 30개가 넘는 서비스들이 네이트브안에서 웹앱으로 돌아가고 있다.</p>\n<p>많은 서비스들을 관리하는 방법은 두가지가 있다.</p>\n<h3>1. 모놀리식 아키텍쳐</h3>\n<p>\"단단히짜여 하나로되어있는\"이라는 뜻이다. 하나의 패키지안에 여러 서비스가 있는 자연스러운 구조이다.</p>\n<h3>장점</h3>\n<p>하나의 큰 리액트 프로젝트 안에 <code class=\"language-text\">행운서비스</code>, <code class=\"language-text\">비대면계좌개설</code>등이 <code class=\"language-text\">서비스폴더</code>로 구분되어있다. 소스들을 공통화 하거나 라이브러리들의 버전관리가 굉장히 간편했다. 템플릿을 만들때도 <code class=\"language-text\">스캐폴딩</code>을 통해 손쉽게 새로운 서비스를 구축할수 있었다. 관리비용이 절감되었다.</p>\n<h3>단점</h3>\n<p>가장 큰 단점은, 빌드 시간이 굉장히 오래걸린다.\n빌드시간이 코드가 늘어감에 따라 <code class=\"language-text\">20분</code>이상이 걸리기도 했다. 배포한번이 굉장히 힘들었다.</p>\n<ul>\n<li>공통화가 많이 되어 있기 때문에 하나의 변경사항이 다른 서비스에 영향을 미칠 수 있다.</li>\n<li>서비스 별로 별도 배포가 불가능했다. (빌드 20분 후 큰 프로젝트 한번에 배포)</li>\n<li>토스는 <code class=\"language-text\">사일로</code>라고하는 기업내 작은 스타트업이 모이는 방식을 채택했는데, <code class=\"language-text\">모놀리식</code>은 이것과 잘 맞지 않는 아키텍쳐였다. 각 <code class=\"language-text\">사일로</code>에는 <code class=\"language-text\">기획자</code>, <code class=\"language-text\">디자이너</code>, <code class=\"language-text\">프론트</code>, <code class=\"language-text\">백엔드</code> 개발자 4명으로 구성되어 있고 각 서비스에 대한 완전한 권한을 갖는다.</li>\n<li>\n<p>사일로의 제품마다 제품 경험이 달랐다.</p>\n<p><code class=\"language-text\">행운퀴즈</code> - PC대응(IE까지)</p>\n<p><code class=\"language-text\">대출맞춤신청</code> - 모바일 웹앱</p>\n<p><code class=\"language-text\">카드값돌려막기</code> - 상태값이 굉장히 복잡하다.</p>\n</li>\n</ul>\n<p>각 서비스 특성마다 사용되는 라이브러리들이 달라지기 시작했고, 서비스를 별도 관리할 필요가 생겼다. 그래서 두번째 아키텍쳐인 <code class=\"language-text\">마이크로서비스 아키텍쳐</code>로 변경했다.</p>\n<p>이 아키텍쳐에서는 각 <code class=\"language-text\">사일로</code> 내의 프론트엔드 개발자가 자발적으로 라이브러리를 선택하고 자율적으로 작업할 수 있게 되었다.</p>\n<ul>\n<li>패키지가 분리되었기 때문에 서비스 마다 라이브러리 의존성 관리가 달라지게 될 수 있었다.\n<code class=\"language-text\">스토리북</code>, <code class=\"language-text\">Mobx</code>, <code class=\"language-text\">RxJs</code>, <code class=\"language-text\">PC대응</code>등을 서비스 마다 선택적으로 사용했다.</li>\n<li>빌드시간이 획기적으로 줄어들었다.( 20분 → 2~3분 )</li>\n<li>하나의 서비스가 다른 서비스에 영향을 미치지 않게 되었다.</li>\n</ul>\n<p>이렇게 패키지를 나눠서 위와 같은 장점이 생겼지만 반대로 공통화가 어려워 졌다. 서비스마다 라이브러리 버전 파편화도 문제였다. 서비스마다 사용하는 라이브러리의 버전이 달랐다.</p>\n<p>새로운 서비스 구축에 많은 비용이 들었다. 레포지토리가 많아지게 되면 잊혀지는 코드들이 생겼다.</p>\n<p>이런 부분을 고려해서 <code class=\"language-text\">Mono Repo</code>라는 아키텍쳐 도입을 고려했다. 이 아키텍쳐는 패키지는 쪼개도 하나의 Repo에 패키지들을 관리한다. <code class=\"language-text\">여러개의 서비스</code>, <code class=\"language-text\">공통 코드</code>, <code class=\"language-text\">라이브러리</code>들을 하나의 Repo안에서 관리할 수 있게 되었다.</p>\n<p><code class=\"language-text\">마이크로서비스 아키텍쳐</code>에서는 <code class=\"language-text\">1Repo</code> <code class=\"language-text\">1Package</code>이지만 <code class=\"language-text\">Mono Repo 아키텍쳐</code>에서는 <code class=\"language-text\">1Repo</code> <code class=\"language-text\">Multiple Package</code> 인걸로 이해된다.</p>\n<p>모놀리식은 <code class=\"language-text\">1Package</code> <code class=\"language-text\">Multiple Services</code></p>\n<h3>모놀리식 아키텍쳐</h3>\n<p>Repo</p>\n<p><code class=\"language-text\">Package</code></p>\n<p>Service</p>\n<p>Service</p>\n<p>Service</p>\n<h3>마이크로 서비스 아키텍쳐</h3>\n<p>Repo</p>\n<p><code class=\"language-text\">Pacakage</code></p>\n<p>Repo</p>\n<p><code class=\"language-text\">Pacakage</code></p>\n<p>Repo</p>\n<p><code class=\"language-text\">Pacakage</code></p>\n<p>Repo</p>\n<p><code class=\"language-text\">Pacakage</code></p>\n<h3>Mono Repo 아키텍쳐 (토스 채택)</h3>\n<p>Repo</p>\n<p><code class=\"language-text\">Package</code></p>\n<p>Service</p>\n<p><code class=\"language-text\">Package</code></p>\n<p>Service</p>\n<p><code class=\"language-text\">바벨</code>, <code class=\"language-text\">emotion js</code>등이 이런 구조를 채택하고 있다.</p>\n<p>토스의 <code class=\"language-text\">Mono Repo</code> 구조</p>\n<p><code class=\"language-text\">Repo</code></p>\n<ul>\n<li><code class=\"language-text\">libraries</code></li>\n<li>컴포넌트 라이브러리</li>\n<li>디자인 시스템 라이브러리</li>\n<li>eslint</li>\n<li><code class=\"language-text\">services</code></li>\n<li>각 서비스들..</li>\n</ul>\n<p><code class=\"language-text\">마이크로 서비스</code> + <code class=\"language-text\">모노 레포</code> 장점</p>\n<ul>\n<li>설정이 굉장히 간편해짐. (루트에서 설정 가져와서 각 서비스에 사용하면됨)</li>\n<li><code class=\"language-text\">코드</code>와 <code class=\"language-text\">이슈</code>를 관리/검색하기 쉬웠다.</li>\n<li>새로운 프로젝트 구축에 비용이 거의 들지 않았다.\n(yarn library mylibray, yarn service myservice)로 간편하게 생성</li>\n</ul>","frontmatter":{"path":"/posts/seminar/1","title":"2019 프론트엔드 밋업(원티드, 배민, 토스)","date":"December 17, 2019"}}},"pageContext":{}}}